# 微信小程序

 `Unit01`

## 下载最新版开发工具（稳定版

<https://developers.weixin.qq.com/miniprogram/dev/devtools/download.html>

微信公众平台.

微信公众平台由腾讯提供，基于腾讯的微信服务器，为广大企业、组织或个人提供用户管理或咨询服务的平台。

**服务号：**

为企业或组织提供的进行用户管理和服务的平台。类似中国移动。

**订阅号：**

为企业、组织或个人提供的进行用户管理和资讯发布的平台。是一种全新的消息传播方式。类似 `CSDN` 。

**小程序：**

为企业、组织或个人提供的可以达到与原生 `app` 功能相同的应用程序解决方案。（在微信内部运行）。其优点在于“小”。用完就走。

## 小程序的接入流程

进入微信公众平台注册开发者账号： `https://mp.weixin.qq.com` 。

流程如下：

1. 首页点击注册。
2. 填写注册信息：新邮箱、密码等。
3. 激活邮箱。
4. 填写主体信息：个人、姓名、身份证号等。
5. 验证成功后进入小程序后台管理页面。

### 创建小程序项目

安装小程序开发工具 `IDE` 。

管理扫码登录，点击新建小程序项目。

填写项目的基本信息。

熟悉开发工具的各个组件布局和环节。

### 小程序项目的文件结构

小程序项目中包含的文件类型有：

1. `json`文件 （配置文件）

`app.json` 全局配置文件

`pages.json` （**统称**，例如： `index.json`  `logs.json` ） 定义单页面的配置参数。

2.`wxml`文件

   模板文件（类似于 `HTML` ，但是此处不能使用任何 `HTML` 标签）

3.`wxss`文件 样式文件（类似`css`，语法与`css`极其相似）

`app.wxss` 用于定义全局样式

`pages.wxss` 用于定义单页的样式

4.`js`文件 脚本文件（写代码的地方）

   ***`app.js` 定义小程序的入口脚本文件***

   当启动小程序时，微信小程序框架将会加载并执行 `app.js` ，初始化 `App` 对象。执行 `App` 中定义的 `onLaunch` 生命周期方法。 `app.js` 仅执行这一次，所以 `App` 对象有且仅有一个，全局单例。

   ***`pages.js` 定义小程序单页面的入口脚本文件***

   当启动小程序中的一个页面时，微信小程序框架将会加载并执行目标页面对应的 `js` 脚本文件，初始化 `Page` 对象。 `Page` 对象中声明了当前页面所定义的相关资源： `data` 、 `methods` 等。还定义了一些页面相关的生命周期方法。

   一个 `Page` 对象对应了一个页面实例。小程序中包含多少个页面实例，就意味着拥有多少个 `Page` 对象。

#### `app.json`

参考文档：<https://developers.weixin.qq.com/miniprogram/dev/reference/configuration/app.html>

`app.json` 用于对小程序进行全局配置。后缀为 `.json` 的文件一定要符合 `json` 的语法格式。要求比较严格：

> 1. `json` 文件中不能写注释。
> 2. 字符串必须在双引号之间。 `json` 对象的属性名也必须在双引号之间。
> 3. 数组或对象的最后一个成员后不能再加逗号 `“, ”` 。
> 4. `json` 中不存在 `undefined` 这种类型。

##### `pages` 配置项

`pages` 配置项用于定义当前小程序中包含哪些页面（ `index` 、 `logs` ）。

```js
"pages":[
 "pages/test/test",
    "pages/index/index",
    "pages/logs/logs"
],
```

新建配置项 `"pages/test/test"` ，将在 `pages` 目录下新建 `test` 目录，然后再其中创建”四件套“。 若配置项写在数组的第一个元素，则会被当做首页显示。

##### `window` 配置项

`window` 配置项用于定义小程序导航栏、标题、窗口的内容或样式（全局生效）。

```js
"window":{
    "enablePullDownRefresh": true,
    "backgroundTextStyle":"dark",
    "backgroundColor": "#999",

    "navigationBarBackgroundColor": "#f00",
    "navigationBarTitleText": "学子影院",
    "navigationBarTextStyle":"white"
},
```

##### `tabbar` 配置项

`tabbar` 用于定义底部选项卡，格式如下：

```json
"tabBar": {
    "color": "#333",
    "selectedColor": "#f00",
    "list": [{
        "text": "电影",
        "pagePath": "pages/index/index",
        "iconPath": "/images/index_disable.png",
        "selectedIconPath": "/images/index_enable.png"
    },{
        "text": "影院",
        "pagePath": "pages/theatre/theatre",
        "iconPath": "/images/theatre_disable.png",
        "selectedIconPath": "/images/theatre_enable.png"
    },{
        "text": "我的",
        "pagePath": "pages/me/me",
        "iconPath": "/images/me_disable.png",
        "selectedIconPath": "/images/me_enable.png"
    }]
},
```

##### `style` 配置项

微信客户端 7.0 开始，UI 界面进行了大改版。小程序也进行了基础组件的样式升级。 `app.json` 中配置 `"style": "v2"` 可表明启用新版的组件样式。

本次改动涉及的组件有 `button icon radio checkbox switch slider` 。可前往小程序示例进行体验。

##### `sitemapLocation` 配置项

`sitemapLocation` 配置项用于指定 `sitemap.json` 配置文件的位置。

微信现已开放小程序内搜索，开发者可以通过 `sitemap.json` 配置，或者管理后台页面收录开关来配置其小程序页面是否允许微信索引。

 `sitemap.json`

该文件用于指定微信官方通用爬虫的检索规则。（指明什么样的页面需要被官方爬虫所收录，什么样的页面不希望被收录。）

```json
"rules": [{
    "action": "disallow",
    "page": "pages/me/me"
  },{
    "action": "allow",
    "page": "*"
}]
```

详细配置见文档：<https://developers.weixin.qq.com/miniprogram/dev/reference/configuration/sitemap.html>

默认情况下，开发工具将会在控制台输出警告来提示收录状态。若不希望看到提示，则需要在 `project.config.json` 配置文件中添加如下配置：

```json
{
  "settings": {
    "checkSiteMap": false
  }
}
```

#### `app.wxss`

用于定义组件的全局样式。

#### `app.js`

**定义小程序的入口脚本文件**

当启动小程序时，微信小程序框架将会加载并执行 `app.js` ，初始化 `App` 对象。执行 `App` 中定义的 `onLaunch` 生命周期方法。 `app.js` 文件仅执行这一次，所以 `App` 对象有且仅有一个，全局单例。

问题：

`app.js` 文件什么时候执行？**当小程序初始化启动时**

`app.js` 文件中的代码执行几次？**一次 `App` 对象是单例的，全局唯一。**

## 小程序组件库

### 组件概述

小程序中 `wxml` 中由各式各样的组件构成。这些组件都是微信自定义的，原生 `html` 标签不能使用。

### `<view>` 组件

`view` 组件为视图容器组件，其基本语法：

```html
<view hover-class="点击后当前view应用的样式类的类名" hover-start-time="" hover-stay-time="" hover-stop-propagation="">
    ...
</view>
```

案例：新建页面： `pages/testing/view/view` ，测试 `view` 的使用。

微信小程序 `Unit02`

## .小程序组件库

### .组件概述

小程序中 `wxml` 中由各式各样的组件构成。这些组件都是微信自定义的，原生 `html` 标签不能使用。

> **关于组件属性**
>
> 1. 对于 `boolean` 类型的属性，无论设置 `true` 还是设置 `false` ，小程序都会当做普通字符串来进行解释，都会被解释为 `true` 。 除非用空字符串 `""` （有点野）。推荐使用 `{{}}` 来设置 `boolean` 类型属性的属性值。
>
>  

```jsx
   hover-stop-propagation="{{false}}"
```

>
> 2.小程序的组件属性名在使用时既遵守驼峰命名法，也遵守短横线命名法，两种属性名的设置都将会生效。

```jsx

### `<view>` 组件

```

`view` 组件为视图容器组件，其基本语法：

```html
<view hover-class="点击后当前view应用的样式类的类名" hover-start-time="点击view后多久开始出现点击状态" hover-stay-time="点击状态停留多久" hover-stop-propagation="">
    ...
</view>
```

案例：新建页面： `pages/testing/view/view` ，测试 `view` 的使用。

### `<image>` 组件

`image` 组件为图片组件，支持 `GIF` 、 `JPG` 、 `PNG` 、 `SVG` 、 `WEBP` 等图像格式。其语法结构：

```html
<image src="图片路径" lazy-load="是否采用图片懒加载" mode="图像的裁切及缩放模式" show-menu-by-longpress="是否在长摁图片时底部弹出操作菜单">
</image>
```

案例： `pages/testing/image/image` 。

### `<swiper>` 组件

`swiper` 组件为轮播图组件，其语法为：

```html
<swiper indicator-dots="{{true}}" indicator-active-color="#0f0" indicator-color="#0f05" autoplay="{{true}}" interval="3000" duration="1000" circular="{{true}}" vertical="{{true}}" easing-function="default">
    <swiper-item>
        <image src="....."></image>
    </swiper-item>
    ......
</swiper>
```

案例： `pages/testing/swiper/swiper` 。测试轮播图。

#### `wxss` 提供的新像素单位： `rpx` （响应式像素）

使用 `rpx` 作为尺寸单位，可以根据屏幕的分辨率动态设置组件的宽高（自适应）。完成屏幕的适配。它的核心原理是：

1. 规定所有的设备的屏幕宽度都是`750rpx`。所以根据这个规定可以计算`rpx`与`px`之间的换算关系。
2. `1rpx` 在不同的设备下将会转换成不同的 `px` 。

| 设备           | `rpx` 换算 `px` (屏幕宽度/750) | `px` 换算 `rpx` (750/屏幕宽度) |
| -------------- | ---------------------------- | ---------------------------- |
| `iPhone5` | `1rpx = 0.42px` | `1px = 2.34rpx` |
| `iPhone6` | `1rpx = 0.5px` | `1px = 2rpx` |
| `iPhone6 Plus` | `1rpx = 0.552px` | `1px = 1.81rpx` |

### `<text>` 组件

`text` 组件为文本组件，其语法：

```html
<text user-select="{{true}}" space="emsp" decode="{{true}}">文本</text>
```

### `<navigator>` 组件

`navigator` 组件属于页面链接组件，用于控制页面之间的跳转。其语法结构：

```html
<navigator url="当前小程序内的页面地址" open-type="跳转方式">
    链接内容
</navigator>
```

`open-type` ：可选项包括：

> 1. `navigate` ，默认的跳转方式。当使用这种方式跳转页面时，将会保留当前页面对象，创建目标页面对象，跳转过去。也称为保留跳转。这种方式无法跳转到 `tabbar` 页面，因为一般 `tabbar` 页面对象都会常驻内存不销毁，也就没有必要新建该页面跳过去了。若希望跳转到 `tabbar` 页面，可以使用 `switchtab` 的方式进行跳转。
> 2. `navigateBack` ， 返回上级页面。这种操作将会销毁当前页面从而显示上一页。可以配合 `delta` 属性实现上 `n` 页的返回。
> 3. `switchTab` ， 字面理解：切换到某个选项卡页面。这种方式可以跳转到带有 `tabbar` 的页面。一旦这么做，将会销毁所有非 `tabbar` 页面。
> 4. `redirect` ，字面理解：重定向。这种跳转方式将会关闭当前页面，重定向到非 `tabbar` 的目标页面。当然也会重新创建目标页。
> 5. `reLaunch` ，字面理解：重新启动小程序 `app` 并打开某个页面。 这种跳转方式将会关闭所有页面，然后重启小程序跳转到指定页面。

案例：新建 3 个页面： `testing/a/a`  `testing/b/b`  `testing/c/c` 。

### `<scroll-view>` 组件

`scroll-view` 组件用于实现滚动的视图容器（支持水平、垂直滚动）。其语法结构：

```html
<scroll-view class="scroll" scroll-y="{{false}}" scroll-x="{{true}}" enable-flex="{{true}}" enhanced="{{true}}" showScrollbar="{{false}}">
    scroll-x="是否允许水平方向滚动" scroll-y="是否允许垂直方向滚动"> 子组件
</scroll-view>
```

若子组件的宽高超出了 `scroll-view` 容器的宽高，则将会在水平、垂直方向上自动出现滚动条。

### `<input>` 组件

`input` 组件为输入框组件，其语法结构为：

```html
<input type="输入框的类型" placeholder="占位字符串内容" value="文本框的值" password="是否为密码框" maxlength="最大长度" focus="设置是否让当前输入框自动获取焦点（将会自动弹出键盘）" bindinput="doInput" 绑定事件的事件处理函数的函数名字>
</input>
```

`type` 的可选值：

> 1. `text` 文本输入键盘
> 2. `number` 数字输入键盘
> 3. `idcard` 身份证键盘
> 4. `digit` 带小数点的键盘

`input` 组件中提供了一些事件处理（ `eventhandle` ）属性。这些属性用于为当前组件绑定事件。在属性值中填写事件处理函数名即可（**注意：严禁出现小括号**）。

```html
<input type="text" placeholder="账号" bindinput="doInput" />
```

一旦设置了 `doInput` ，则需要在 `page.js` 中声明 `doInput` 方法用于处理该事件。 `doInput` 方法内部也会传入 `event` 事件对象，用于封装该事件相关的参数信息。

```javascript
/** 处理bindinput事件 */
doInput(event) { // 获取文本框中输入的内容    console.log(event.detail.value);},
```

#### 小程序表单组件的双向数据绑定

### `WXML` 数据渲染语法基础

`wxml` 的 `data` 中声明很多的动态数据，这些数据可以在 `js` 中进行修改，从而在页面中动态实时更新。

```javascript
Page({
    data: {
        name: "张三",
        age: 18,
        imgurl: "http://1.jpg",
        bgcolor: "red",
        hobby: [c, h, w, l],
    },
})
```

#### 文本内容绑定

动态更新标签的内容文本，使之与 `data` 中声明的属性保持实时同步。

```html
<view>姓名：{{name}}</view>
<view>年龄：{{age}}</view>
<view>婚否：{{married?'已婚':'未婚'}}</view>
<view>毕业院校： {{school.loc}}, {{school.name}}</view>
```

#### 属性绑定

动态更新组件的属性值。

```javascript
data: {
    imgurl: '/images/1.jpg',
    num: 1,
    showbar: false
}
```

```html
<image src="{{imgurl}}"></image>
<image src="/images/{{num}}.jpg"></image>
<scroll-view showScrollbar="{{showbar}}"></scroll-view>
```

#### 样式绑定

动态修改组件的 `wxss` 样式。

```javascript
data: {
    className: 'bgred',
    color: 'red',
    bw: 1
}
```

```html
<view class="{{className}}"></view>
<view style="color:{{color}}; border:{{bw}}px solid black;"></view>
```

#### 列表渲染

基于小程序提供的列表渲染的语法，可以动态的输出数组数据。（类似 `vue` 中的 `v-for` ）基本语法如下：

```javascript
data: {
    products: [{
            id: 1,
            name: "薯片",
            price: 4.5,
            num: 5
        },
        {
            id: 2,
            name: "果冻",
            price: 5.5,
            num: 3
        },
        {
            id: 3,
            name: "瓜子",
            price: 1.5,
            num: 4
        },
        {
            id: 4,
            name: "花生",
            price: 0.5,
            num: 10
        },
    ]
}
```

`vue` 中如何将该列表渲染到页面中：

```html
<view v-for="(item,index) in products" :key="index">
    <view>{{item.name}}</view>
    <view>{{item.price}}</view>
    <view>{{item.num}}</view>
</view>
```

微信小程序中使用 `wx:for` 来完成列表渲染业务，语法如下：

```html
<view wx:for="{{products}}">
    <view>{{item.name}}</view>
    <view>{{item.price}}</view>
    <view>{{item.num}}</view>
</view>
```

```html
`wx:for` 类似 `vue` 中 `v-for` ，可以方便的完成列表数据的渲染。在遍历渲染过程中，小程序自动把每个对象赋值给变量: `item` ，所以我们可以通过 `{{item. 属性}}` 访问对象中的属性值，从而渲染页面内容。同理，小程序也将会把遍历过程中每个元素对应的下标赋值给变量: `index` 。我们可以使用 `{{index}}` 来访问下标。

案例：造一组商品数据，遍历输出。

我们可以自定义变量名 `pro` 来引用遍历过程中数组的每个元素，也可以自定义变量名 `i` 来引用遍历过程中每个元素对应的下标。只需要分别设置 `wx:for-item` 与 `wx:for-index` 属性即可。写法如下：
```

```html
<view style="margin:10px; border:1px solid black;" wx:for="{{products}}" wx:for-item="pro" wx:for-index="i">
    <view>{{i+1}}</view>
    <view>{{pro.name}}</view>
    <view>￥{{pro.price}}</view>
</view>
```

控制台将会给出警告，建议添加 `wx:key` 用于提升列表渲染的性能。

##### `wx:key`

如果列表中列表项的位置会动态改变或者有新的列表项添加到列表中，并且希望列表中的列表项保持自己的特征和状态，需要使用 `wx:key` 来指定列表中列表项的唯一的标识符。

`wx:key` 的值以两种形式提供

1. 字符串，代表在 `for` 循环的 `array` 中 `item` 的某个 `property`，该 `property` 的值需要是列表中唯一的字符串或数字，且不能动态改变。
2. 保留关键字 `*this` 代表在 `for` 循环中的 `item` 本身，这种表示需要 `item` 本身是一个唯一的字符串或者数字。

当数据改变触发渲染层重新渲染的时候，会校正带有 key 的组件，框架会确保他们被重新排序，而不是重新创建，以确保使组件保持自身的状态，并且提高列表渲染时的效率。

**如不提供 `wx:key` ，会报一个 `warning` ， 如果明确知道该列表是静态，或者不必关注其顺序，可以选择忽略。**

#### 条件渲染

使用条件渲染可以动态处理是否渲染某个元素。类似 `vue` 中的 `v-if` 。例如：

```javascript
data: {
    islogin: true
}
```

```html
<view wx:if="{{islogin}}">欢迎：张三</view>
<view wx:else>登录 注册</view>
```

条件渲染的常用写法如下：

```html
<text wx:if="{{条件表达式}}">内容</text>----------------------------------------------------------<text wx:if="{{条件表达式}}">内容A</text><text wx:else>内容B<text>----------------------------------------------------------
        <text wx:if="{{条件表达式}}">内容A</text><text wx:elif="{{条件表达式}}">内容B</text><text wx:elif="{{条件表达式}}">内容C</text><text wx:elif="{{条件表达式}}">内容D</text><text wx:else>内容E</text></text></text>
```

### `<radio-group>` 组件

`radio-group` 组件为单选框组组件，其基本结构如下：

```html
<radio-group>
    <radio value="M" checked color="">男</radio>
    <radio value="F" color="">女</radio>
</radio-group>
```

案例：设计一道单选题，测试 `radio-group` 的使用。

### `<checkbox-group>` 组件

`checkbox-group` 组件为复选框组 组件，其语法为：

```html
<checkbox-group>
    <checkbox value="" checked color="">A选项</checkbox>
    <checkbox value="" color="">B选项</checkbox>
    <checkbox value="" color="">C选项</checkbox>
</checkbox-group>
```

### `<picker>` 组件

`picker` 用于定义底部弹出的滚动选择器，有多种类型，可以通过 `picker` 组件的 `mode` 属性来进行定义：

> 1. `selector` 单列滚动选择器
> 2. `multiSelector` 多列滚动选择器
> 3. `date` 日期选择器
> 4. `time` 时间选择器
> 5. `region` 行政区划选择器

 微信小程序 `Unit04`

### `<button>` 组件

案例：新建 `testing/button/button` 页面，测试按钮组件。

### 小程序事件基础

事件是视图层到逻辑层的通讯方式。它可以将用户的欣慰反馈到逻辑层进行后续处理。

#### 小程序中的事件类型

在微信小程序中，事件类型分为两类：

1. 冒泡事件：当一个组件上的事件被触发后，该事件会向父节点传递。

   WXML 的冒泡事件列表：

   | 类型                 | 触发条件                                                                                  |
   | -------------------- | ----------------------------------------------------------------------------------------- |
   | `touchstart` | 手指触摸动作开始                                                                          |
   | `touchmove` | 手指触摸后移动                                                                            |
   | `touchcancel` | 手指触摸动作被打断，如来电提醒，弹窗                                                      |
   | `touchend` | 手指触摸动作结束                                                                          |
   | `tap` | 手指触摸后马上离开                                                                        |
   | `longpress` | 手指触摸后，超过 350ms 再离开，如果指定了事件回调函数并触发了这个事件，tap 事件将不被触发 |
   | `longtap` | 手指触摸后，超过 350ms 再离开（推荐使用 longpress 事件代替）                              |
   | `transitionend` | 会在 WXSS transition 或 wx.createAnimation 动画结束后触发                                 |
   | `animationstart` | 会在一个 WXSS animation 动画开始时触发                                                    |
   | `animationiteration` | 会在一个 WXSS animation 一次迭代结束时触发                                                |
   | `animationend` | 会在一个 WXSS animation 动画完成时触发                                                    |

2. 非冒泡事件：当一个组件上的事件被触发后，该事件不会向父节点传递。

   **除上表之外的其他组件自定义事件如无特殊声明都是非冒泡事件，如 form 的 submit 事件，input 的 input 事件，scroll-view 的 scroll 事件，(详见各个组件)**

#### 小程序中的事件绑定方式

小程序中绑定事件的方式介绍如下 3 种：

```html
<button bind事件名="事件处理函数的函数名">按钮</button>
<button bind:事件名="事件处理函数的函数名">按钮</button>
<button catch事件名="事件处理函数的函数名">按钮</button>
```

`bind` 方式绑定事件可以应用于任何组件，而 `bind:` 方式不能用于为**原生组件**绑定事件。

> 原生组件指由手机操作系统控制的组件，并不是微信自定义的组件。如 `video` 组件、 `camera` 组件、获取焦点之后的 `input` 组件等。原生组件的特点是由 `Android` 与 `IOS` 操作系统直接提供显示在页面上，并不是微信自己实现的 `UI` 。

`bind` 与 `bind:` 这两种方式绑定的事件不能阻止事件冒泡，但是 `catch` 绑定的事件可以自动阻止事件冒泡。

案例：使用不同的事件绑定方式，为组件绑定 `tap` 事件。测试冒泡效果。

#### 小程序的事件参数的传递

无论组件绑定的是冒泡事件还是非冒泡事件，事件处理函数名一律不准添加小括号

```html
<button bindtap="tapEvent">按钮</button>
<input bindinput="inputEvent"></input>
```

如何进行事件的传递？

**对于非冒泡事件（自定义事件）**，事件由组件自定义，当触发了该事件后，一般情况下组件都会将相关的参数直接存入事件对象中（ `event.detail` ）。所以，我们可以在事件处理函数中直接访问 `event.detail` 来获取相关参数：

```html
<input bindinput="inputEvent"></input>
```

```javascript
inputEvent(event) {
    event.detail.value // 获取文本框的值
    event.detail.cursor // 获取当前光标位置
    event.detail.code // 获取当前输入字符的键值
}
```

**对冒泡事件（原生事件）**，事件参数传递的语法如下：

```html
<button data-index="0" bindtap="delete">删除A购物项</button>
<button data-index="1" bindtap="delete">删除B购物项</button>
<button data-index="2" data-id="1003" bindtap="delete">删除C购物项</button>
```

```javascript
delete(event) {
    // 删除相应购物项
    let index = event.target.dataset.index;
    this.setData({
        .....
    })
}
```

案例：吃饭睡觉打豆豆。 `pages/testing/todo/todo`

## 微信小程序 `API`

### 界面交互类 `API`

#### `Toast` 消息提示框

```javascript
wx.showToast({
    title: "添加成功",
    icon: "success",
    duration: 10000,
    mask: true,
    success: (res) => {},
    fail: (res) => {},
    complete: (res) => {},
})
```

<https://developers.weixin.qq.com/miniprogram/dev/api/ui/interaction/wx.showToast.html>

#### `Modal` 对话框

```javascript
wx.showModal({
    cancelColor: "#555",
    cancelText: "我再想想",
    confirmColor: "#f00",
    confirmText: "残忍删除",
    title: "提示",
    content: "确认删除吗？",
    success: (res) => {
        console.log(res)
        if (res.confirm) {
            let i = event.target.dataset.i
            let todos = this.data.todos
            todos.splice(i, 1)
            this.setData({
                todos
            })
        }
    },
})
```

### 路由类 `API`

* `wx.switchTab` 切换选项卡。干掉所有非`tabbar`页。跳转到`tabbar`页面。
* `wx.reLaunch` 重启动。干掉所有页面，创建新页面，跳转过去。
* `wx.redirectTo` 重定向。干掉自己，创建对方，跳转过去。
* `wx.navigateTo` 保留跳转。保留自己，创建对方，跳转过去。
* `wx.navigateBack` 返回。 干掉自己，实现返回。

#### `wx.navigateTo()` 保留跳转

保留当前页面，跳转到应用内的某个其它页面。不能跳转到 `tabbar` 页面。可以通过 `wx.navigateBack()` 方法返回到原页面。

在跳转页面的过程中，可以进行**页面间参数的传递**。这个需求也是在以后开发过程中经常需要使用的需求。小程序中跳转页面时（假设 a 页面跳转到 b 页面），可能会出现正向传参与反向传参的需求：

**正向传参**

`A` 页面跳转到 `B` 页面，并且携带参数跳转的过程。

```javascript
// A 页面wx.navigateTo({    url: '/pages/testing/b/b?id=1&name=zs&age=18'})// B 页面Page({    onLoad(options){   // 生命周期方法   页面加载时执行        // options封装了请求参数    ?id=1&name=zs&age=18        options.id        options.name        options.age    }})
```

**反向传参**

`A` 页面跳转到 `B` 页面，在 `B` 页面中进行操作后，返回 `A` 页面并且携带参数回传给 `A` 页面的过程。

```javascript
// A页面wx.navigateTo({    url: '/pages/testing/b/b',    events: {        acceptData: (data)=>{  // 回调方法 用于接收B回传回来的data            // data就是B页面传回来的数据，在此可以更新UI。        }    }})
```

```javascript
// B页面onLoad(){    let eventChannel = this.getOpenerEventChannel();    eventChannel.emit("acceptData", "杭州");    wx.navigateBack();}
```

/\*_生命周期函数--监听页面加载 执行一次_/
onLoad: function (options) {
console.log('A onLoad...')
},

/\*_生命周期函数--监听页面初次渲染完成 执行一次_/
onReady: function () {
console.log('A onReady...')
},

/\*_生命周期函数--监听页面显示 执行多次_/
onShow: function () {
console.log('A onShow...')
},

/\*_生命周期函数--监听页面隐藏 执行多次_/
onHide: function () {
console.log('A onHide...')
},

/\*_生命周期函数--监听页面卸载 执行一次_/
onUnload: function () {
console.log('A onUnload...')
},

## 微信小程序的生命周期

微信小程序的生命周期分两类：

1. 小程序页面的生命周期

2. 小程序应用的生命周期

### 小程序页面的生命周期

小程序页面的生命周期需要在 `Page.js` 中进行定义，从一个页面创建到该页面销毁将会自动执行不同的生命周期方法：

```微信小程序
/**  生命周期函数--监听页面加载 执行一次 */
onLoad: function (options) {
    console.log('A onLoad...')
},

/** 生命周期函数--监听页面初次渲染完成  执行一次 */
onReady: function () {
    console.log('A onReady...')
},

/** 生命周期函数--监听页面显示 执行多次 */
onShow: function () {
 console.log('A onShow...')
},

/** 生命周期函数--监听页面隐藏  执行多次 */
onHide: function () {
 console.log('A onHide...')
},

/** 生命周期函数--监听页面卸载 执行一次 */
onUnload: function () {
 console.log('A onUnload...')
},
```

搞清楚生命周期方法的调用顺序。 `load show ready [hide show]+ unload`

搞清楚每个生命周期方法的执行时机。

写代码是要找准生命周期方法，重写该生命周期方法实现业务。

### 小程序应用的生命周期

小程序应用从启动到使用到销毁也会涉及到整个应用程序的生命周期。这些生命周期方法定义在 `app.js` 中。

```javascript
// app.   Application  应用程序
App({
            /** 生命周期方法，小程序第一次启动时触发 (触发一次) */
            onLaunch() {
                console.log('onLaunch...');
            },
            /** 生命周期方法，当小程序隐藏后后台时（切换应用） 可以触发多次 */
            onHide() {
                console.log('onhide...');
            },
            /** 生命周期方法，但小程序回到前台时（切换应用） 可以触发多次*/
            onShow() {
                console.log('onshow...');
            },
        }
```

案例：模拟银行 `APP` ，应用隐藏后台后提示。返回前台后计算时间，若超出 10 秒则提示请重新登录。

1. 在`globalData`中存储一个时间戳，表示将应用隐藏到后台时的时间。
2. 当应用`onHide`时，把当前时间戳存入`globalData`。
3. 当应用`onShow`时，记录当前时间戳，将`globalData`中的时间拿到，相减，判断是否超时并提示即可。

`globalData` 是 `App` 对象的属性，可以直接访问。字面理解： `globalData` == 本地数据。它的作用就是存储全局共享的数据，是一个可以在页面中随时访问的数据存储区。所以我们可以将一些全局共享数据存入 `globalData` ，供以后需求进行使用。

**如何存？**

```微信小程序
// 存入一个变量 lasttime
this.globalData.lasttime = 6745263458623;
```

**如何取**？

```微信小程序
let t = this.globalData.lasttime;
```

上述存、取的相关操作只能在 `app.js` 中执行。但是如果需要在 `Page` 对象中获取 `globalData` 中的数据时需要编写以下代码：

**如何存？**

```微信小程序
Page({
    onLoad(){
        getApp().globalData.lasttime = 14672093546;
    }
})
```

**如何取？**

```javascript
Page({
    onLoad() {
        let t = getApp().globalData.lasttime
    },
})
```

### 微信小程序网络相关 `API`

小程序对于发送 `http` 请求有一些限制：

> 1. 请求资源路径只支持 `https` 。
> 2. 请求资源路径必须指定具体域名，而非 `IP` 地址。
> 3. 域名必须经过 `ICP` 备案。
> 4. 小程序使用的域名必须要在后台管理网站中注册。申请为合法域名。
> 5. 配置时，不支持配置父域名，使用子域名的情况。
> 6. 对于每个小程序，最多可以配置 200 个域名。

### 测试连接

### `https://api.tedu.cn/index.php?cid=1`

若访问不到，因为网络配置原因。可以修改 `DNS` 为 `114.114.114.114` 。但是该 `DNS` 无法观看内网视频，需要看视频再改回来即可。

#### 服务器域名配置

小程序使用的域名必须要在后台管理网站中注册申请为合法域名。申请步骤如下：

1. 扫码登录后台管理网站：`mp.weixin.qq.com`

2. 左侧边栏导航中选择：**开发管理** -- **开发设置**

3. 往下翻到**服务器域名**，点击**开通**或**修改**。添加要访问的服务器域名：

```微信小程序
   https://api.tedu.cn
   ```

4.去小程序开发工具中验证是否添加成功。

   点击**详情**按钮， 查看**项目配置**， 看一下**域名信息**中是否已经完成更新。

#### `wx.request()`

`wx.request()` 用于发送 `https` 请求，其语法：

```javascript
wx.request({
    url: "请求资源路径",
    method: "POST  请求方式",
    header: {
        cookie: 'key=value',
        token: 'xxxxxxxxxxx'
    },
    data: {
        name: 'zs',
        age: 15
    },
    请求参数
    success: (res) => {},
    响应接收成功后的回调方法
    fail: (err) => {},
    请求发送失败后的回调方法
    complete: (com) => {}
    无论请求成功与否获取响应后都会执行的回调方法
})
```

案例，向测试接口发请求。

## 学子影院

### 初始化项目

1. 新建项目。
2. 搭建项目的基本主体结构。
   1. 新建页面 `/index/index`  `/theatre/theatre`  `/me/me` 。
   2. 拷贝项目所需要的图片资源。
   3. 搭建底部选项卡的基本结构。
3. 针对`sitmap.json`进行基本配置。可以修改`project.config.json`，关闭`sitmap`的检查。

### 初始化加载热映类别下的电影列表

***通过类别 ID 访问电影列表数据接口***

|          | 说明                                                                                                      |
| -------- | --------------------------------------------------------------------------------------------------------- |
| 接口地址 | `https://api.tedu.cn/index.php` |
| 请求方式 | `GET` |
| 请求参数 | `cid` : 类别 `ID` [1：热映 2：待映 3：经典]`<br>` `offset` : 开始读取条目的起始位置（用于分页）                 |
| 响应格式 | 从 `offset` 位置开始向后数 20 条数据组成的电影列表。`<br>` `[{电影对象}, {电影对象}, {电影对象}, {电影对象}....]` |

每个电影对象包含的属性有：

```微信小程序
actors: "章若楠／孙晨竣／王彦霖"cover: "https://p1.meituan.net/movie/f6ec2a022d3644ef493f881d359f65303190471.jpg@218w_300h_1e_1c"id: "1"moviename: "如果声音不记得"movietype: "爱情／青春／奇幻"score: "8.2"
```

**实现思路：**

1. 在`index`页面的生命周期方法：`onLoad`中发送请求，访问`cid=1`（热映类别）下的第一页（`offset=0`）电影列表数据。
2. 获取响应，解析后完成列表渲染。（`wx:for`）

### 切换顶部导航选中项更新列表

**实现思路：**

1. 在`data`中声明`cid`属性用于保存当前选中的类别`id`。
2. 动态更新页面中的选中项样式。判断是否需要添加`hot-item-active`类。
3. 为 3 个`text`绑定`tap`事件，点击后，修改`data`中的`cid`，那么随着`cid`的改变，页面导航的选中项自然也会随之更新。
4. 不仅要更新样式，还需要在选中某个类别后重新发送请求，访问新类别下的列表数据。
5. 一旦拿到响应数据，替换当前`movies`列表，完成列表渲染即可。

### 页面滚动到底部后加载下一页

**实现思路：**

1. 重写`Page.onReachBottom`方法，该方法将会在触底后自动调用。
2. 在`onReachBottom`方法中发送`http`请求，访问当前类别的下一页数据。
3. 获取到新数据后，需要把得到的电影列表追加到当前电影列表的末尾。

### 封装 `loadMovies` 方法

封装一个方法 `loadMovies` ，，用于发送电影列表请求，获取返回的电影列表数据。

```微信小程序
loadMovies(cid, offset){ return new Promise((resolve, reject)=>{        wx.request({          url: 'https://api.tedu.cn/index.php',          method: 'GET',          data: {cid, offset},          success: (res)=>{           resolve(res.data)          }        }) });}onLoad(){ loadMovies(1, 1).then((movielist)=>{        // movielist即是发请求返回的响应数据  电影列表 })}tapNav(){    }onReachBottom(){    }
```

### .封装 `loadMovies` 方法

封装一个方法 `loadMovies` ，，用于发送电影列表请求，获取返回的电影列表数据。

```微信小程序
loadMovies(cid, offset){
 return new Promise((resolve, reject)=>{
        wx.request({
          url: 'https://api.tedu.cn/index.php',
          method: 'GET',
          data: {cid, offset},
          success: (res)=>{
           resolve(res.data)
          }
        })
 });
}

onLoad(){
 loadMovies(1, 1).then((movielist)=>{
        // movielist即是发请求返回的响应数据  电影列表
 })
}
tapNav(){
    loadMovies(1, 1).then((movielist)=>{
        // movielist即是发请求返回的响应数据  电影列表
 })
}
onReachBottom(){
    loadMovies(1, 1).then((movielist)=>{
        // movielist即是发请求返回的响应数据  电影列表
 })
}
```

### 小程序缓存设计方案

**什么是缓存？**

客户端向服务端发送请求试图获取一组数据，当数据下载完毕后，客户端可以将这组数据**缓存**到客户端客户端本地。当下次再需要发送请求时，先去缓存区域中搜索，若可以找到需要的数据，直接使用，不必访问服务器。若没有，再去发请求。

**什么样的业务适合使用缓存？**

数据变化要小。

访问量越大，缓存对性能的优化效果就越明显。

> 注意：一旦真实数据发生了改变，缓存中的数据也应该想办法更新。

到底何时更新客户端缓存与项目的业务形态有直接关系。

### 切换选项卡的时候处理缓存

***实现步骤***

1. 当切换选项卡时，从服务端下载完数据后将数据存入客户端缓存。

```javascript
   wx.setStorage({
       key: `${cid}`,
       value: movies,
   })
```

### 基于下拉刷新实现缓存的更新

**实现步骤**：

1. 在`index.json`进行配置，开启下拉刷新：

```json
   {
     "enablePullDownRefresh": true,
     "backgroundColor": "#ccc"
   }
   ```

2.在`index.js`的`onPullDownRegresh`方法中，发送请求，更新缓存.

```javascript
   /** 当下拉刷新时执行 */
   onPullDownRefresh() {
       console.log('pull down refresh...');
       // 发送http请求，获取最新列表数据，更新缓存
       this.loadMovies(this.data.cid, 0).then(movies => {
           this.setData({
               movies
           }); // UI列表更新
           wx.stopPullDownRefresh();
           // 更新缓存
           wx.setStorage({
               key: this.data.cid,
               data: movies
           })
       })
   }
```

### 更新左上角定位城市

基于**腾讯位置服务**完成逆地址查询（通过当前位置经纬度，查询所在城市）。

#### 接入腾讯位置服务

![1629687426283](C:\Users\web\AppData\Roaming\Typora\typora-user-images\1629687426283.png)

> 1. 申请开发者密钥（key）：[申请密钥](https://lbs.qq.com/dev/console/application/mine)
>
> 2. 开通 webserviceAPI 服务：控制台 ->应用管理 -> [我的应用](https://lbs.qq.com/dev/console/key/manage) ->添加 key-> 勾选 WebServiceAPI -> 保存
>
> (小程序 SDK 需要用到 webserviceAPI 的部分服务，所以使用该功能的 KEY 需要具备相应的权限)
>
> 3.下载微信小程序 JavaScriptSDK，微信小程序[JavaScriptSDK v1.1](https://mapapi.qq.com/web/miniprogram/JSSDK/qqmap-wx-jssdk1.1.zip) [JavaScriptSDK v1.2](https://mapapi.qq.com/web/miniprogram/JSSDK/qqmap-wx-jssdk1.2.zip)
>
> 4.安全域名设置，在[小程序管理后台](https://mp.weixin.qq.com/wxamp/home/guide) -> 开发 -> 开发管理 -> 开发设置 -> “服务器域名” 中设置 request 合法域名，添加<https://apis.map.qq.com>
>
> 5.小程序示例

### 显示电影详情页

#### 通过 `id` 查询电影详情接口

|              | 说明                             |
| ------------ | -------------------------------- |
| 接口地址     | `https://api.tedu.cn/detail.php` |
| 请求方式     | `GET` |
| 请求参数     | `id:影片ID` |
| 返回数据格式 | 返回相应 `id` 的电影具体数据       |

```微信小程序
actor: [,…]
cover: "https://xxxx.jpg"
description: "如果你喜欢的女孩，得了抑郁症，你该怎么办？辛唐（孙晨竣 饰）拥有通过声音给他人制造快乐的能力，但对同一人使用三次后，性命就会和此人绑定，只有对方开心，辛唐才能活命。偶然，辛唐救下准备自杀的同校网络红人吉择（章若楠 饰），两人借此绑定。吉择表面开朗，但实际患了抑郁症。辛唐最初为了活下去，费尽心思让吉择开心，而后续也真的投入深情。遗憾辛唐的秘密总会败露，而吉择暗黑的过往也在网络上被人揭开....愿爱情的温暖，能治愈抑郁的青春。"
director: [,…]
moviename: "如果声音不记得"
movietype: "爱情／青春／奇幻"
score: "8.2"
showingon: "2020-12-04"
star: "章若楠／孙晨竣／王彦霖"
thumb: [...]
```

***实现步骤***

1. 新建电影详情页，将资源覆盖掉`movie.wxml` `movie.wxss`.

2. 当在`index.wxml`中点击列表项时，跳转到`movie`页面，且需要在`movie`页面中显示当前选中项的电影详情信息。就需要将选中项的`movieid`传给`movie`页面。

```html
   <!-- index.wxml -->
   <navigator url="/pages/movie/movie?movieid={{movieid}}"> </navigator>
```

```javascript
   //movie.js
   Page({
       onLoad(options) {
           //options 封装了传来的参数。movieid
           options.movieid
       },
   })
```

3.在`movie`页面中获取列表页面传过来的`id`，通过`id`发送`http`请求。

4.获取响应后，渲染详情页页面的每个部分。

   1. 基本信息内容。
   2. 导演数组： `movie.director`  `[{}, {}, {}, {}]`

   3. 演员数组： `movie.actor`  `[{}, {}, {}, {}]`

   4. 剧照数组： `movie.thumb`  `['url', 'url', 'url', ]`

5.全屏大图浏览剧照数组。

```javascript
   tapImage(event) {
       let index = event.currentTarget.dataset.index;
       console.log(index);

       let urls = this.data.movie.thumb;
       let newUrls = [];
       urls.forEach(item => {
           newUrls.push(
               item.substring(0, item.lastIndexOf('@')))
       });
       wx.previewImage({
           urls: newUrls
       })
   },
```

6.实现电影描述信息的展开与收起。

   1. 控制电影描述信息的展开与收起使用的是一个类名： `line-clamp` 。可以在 `data` 中声明一个变量 `isOpen` 用于保存当前简介内容展开与收起的状态。 `isOpen=true` ：展开。 反之则收起。
   2. 为简介内容绑定 `tap` 事件，当点击简介时，修改 `isOpen` 的值，从而动态更新界面效果。

**在小程序事件参数传递的过程中， `target` 与 `currentTarget` 的区别。**

`event.currentTarget` 可以获取绑定当前事件的事件源对象（事件绑定给谁， `currentTarget` 指的就是谁）。

`event.target` 可以获取最先触发事件的事件源对象。就算 `tap` 事件绑定给了父元素，当点击子元素时，父元素事件处理函数中的 `event.target` 依然指向这个最先触发事件的子元素事件源对象。

## 小程序云开发

### 概述

开发者可以使用腾讯提供的云服务器来开发微信小程序、小游戏，而无需搭建服务器。云开发提供的基础能力有：

1. 云数据库

   是一个可以在小程序前端通过 `API` 直接操作的非关系型数据库。真实数据存储在微信云服务器中。

2. 云存储

   云存储支持在小程序前端通过 `API` 直接操作文件的上传与下载。类似百度网盘。

3. 云函数

   云函数是在小程序端定义，后期部署到云服务器，并且在云服务器端执行（小程序端通过 `API` 调用）的函数。

### 开通云开发服务

单击开发工具工具栏中的**云开发**按钮。

## .小程序云开发

### .概述

开发者可以使用腾讯提供的云服务器来开发微信小程序、小游戏，而无需搭建服务器。云开发提供的基础能力有：

1. 云数据库

   是一个可以在小程序前端通过 `API` 直接操作的非关系型数据库。真实数据存储在微信云服务器中。

2. 云存储

   云存储支持在小程序前端通过 `API` 直接操作文件的上传与下载。类似百度网盘。

3. 云函数

   云函数是在小程序端定义，后期部署到云服务器，并且在云服务器端执行（小程序端通过 `API` 调用）的函数。

### /开通云开发服务

单击开发工具工具栏中的**云开发**按钮。

电影表

| 字段        | 说明     |
| ----------- | -------- |
| id          | 主键 ID  |
| score       | 评分     |
| star        | 主演     |
| showingon   | 上映时间 |
| movietype   | 电影类型 |
| moviename   | 电影名称 |
| description | 简介     |

电影-演员中间表（配置表）

| 字段     | 说明    |
| -------- | ------- |
| id       | 主键    |
| movie_id | 电影 id |
| actor_id | 演员 id |

演员表

| 字段   | 说明     |
| ------ | -------- |
| id     | 主键 ID  |
| avatar | 头像路径 |
| name   | 演员名称 |

`photo` 表（剧照表）

| 字段     | 说明          |
| -------- | ------------- |
| id       | 剧照 id       |
| url      | 剧照 url 路径 |
| movie_id | 电影 id       |

电影表 - 剧照表 一对多，可以在多的一方设计一个外键关联字段，关联一的一方的主键 ID。

评论表

| 字段     | 说明     |
| -------- | -------- |
| id       | 主键 id  |
| avatar   | 头像路径 |
| nickname | 昵称     |
| content  | 评论内容 |
| movie_id | 电影 ID  |

电影表 - 评论表 一对多

 `create database xzyy default charset utf8`

 `use xzyy;`

建表：

```微信小程序
create table comment(
 id int primary key auto_increment,
 avatar varchar(255),
 nickname varchar(50),
 content varchar(255),
 movie_id int
);
insert into comment values (1, '1.jpg','zs','very good!', 1);
insert into comment values (2, '1.jpg','ls','very good!', 1);
insert into comment values (3, '1.jpg','ww','very laji!', 1);
insert into comment values (4, '1.jpg','zl','so so!', 1);
insert into comment values (5, '1.jpg','tq','nan kan!', 2);
insert into comment values (6, '1.jpg','wb','hai xing!', 2);

select * from comment where movie_id=1 limit 0,2;
```

### 云数据库

是一个可以在小程序前端通过 `API` 直接操作的非关系型数据库（基于 `MongoDB` ）。真实数据存储在微信云服务器中。

#### 关系型数据库与 `json` 型数据库的区别

***关系型数据库***

| id  | name | sex | school_id |
| --- | ---- | --- | --------- |
| 1   | zs   | m   | 1         |
| 2   | ls   | m   | 1         |
| 3   | tq   | f   | 2         |

| id  | school_name | school_loc | area |
| --- | ----------- | ---------- | ---- |
| 1   | qh          | bj         | 1000 |
| 2   | bd          | bj         | 850  |

**`json` 型数据库**

```http
[
    {
        id: 1,
        name: 'zs',
        sex: 'm',
        school: {
            id: 1,
            school_name: 'qh',
            school_loc": 'bj',
            area: 1000
        }
    },
    {
        id: 2,
        name: 'ls',
        sex: 'm',
        school: {
            id: 1,
            school_name: 'qh',
            school_loc": 'bj',
            area: 1000
        }
    },
    {
        id: 3,
        name: 'tq',
        sex: 'f',
        school: {
            id: 2,
            school_name: 'bd',
            school_loc: 'bj',
            area: 850
        }
    }
]
```

#### 二者概念上的区别

| 关系型数据库 | `json` 型数据库   |
| ------------ | ---------------- |
| 数据库       | 数据库           |
| 数据表       | 集合             |
| 行、记录     | 记录、文档、对象 |
| 列、字段     | 字段、属性       |

### 云数据库的程序操作

#### 初始化

获取操作数据库的引用 `db` 对象：

```javascript
const db = wx.cloud.database({
    env: "环境ID  环境ID可以通过云开发控制台-设置中复制过来",
})
```

#### 插入数据

调用 `collection` 方法，获取操作某个集合的引用对象：

```javascript
let coll = db.collection("users")
```

调用 `coll` 的 `add` 方法，可以添加新数据：

```javascript
coll.add({
    data: {}, // 指明 需要插入集合的数据
    success: (res) => {}, // 插入成功后的回调方法
})
```

案例：新建云开发项目，新建页面 `pages/add/add` ，测试云数据库的添加操作。

#### 查询数据

##### 获取一个记录的数据（通过 `_id` 主键查询一条记录）

获取一条记录的 `API` 如下：

```javascript
db.collection("集合名字")
    .doc("记录的主键 _id ")
    .get()
    .then((res) => {
        console.log(res)
    })
```

通过 `id` 查找一条数据时，可能找得到，可能找不到（**由于权限问题**）。若能找到将会回调 `promise` 的 `resolve` ，若找不到则会回调 `promise` 的 `reject` 。

##### 获取多个记录的数据

```javascript
db.collection('users')
    .where({
        married: false
    })
    .get()
    .then(res => {
        ...
    })
```

`where` 方法接收一个对象参数，该对象中每个字段和它的值构成一个需满足的匹配条件，各个字段间的关系是 "与" 的关系，即需同时满足这些匹配条件。

#### 实现项目中的评论功能

1. 下载`comments.json`，通过云控制台导入云数据库 `comments`集合中。
2. 新建云开发项目，将已经完成的旧项目中的代码，覆盖到新项目中。
3. 在新项目中，当详情页加载时，访问云数据库，拉取所有评论信息。（注意权限）。
4. 获取返回的数据后，完成列表渲染即可。

#### `Collection` 对象

调用 `db.collection()` 可以获取一个 `Collection` 对象。它表达了数据库集合的引用。 `collection` 封装了很多属性及方法用于对该集合进行操作。

| 方法                   | 描述                        |
| ---------------------- | --------------------------- |
| `collection.get()` | 查询数据                    |
| `collection.add()` | 添加数据                    |
| `collection.update()` | 修改数据                    |
| `collection.remove()` | 删除数据                    |
| `collection.where()` | 添加筛选条件                |
| `collection.skip()` | 跳过 n 条记录               |
| `collection.limit(n)` | 从当前位置向后查询 n 条记录 |
| `collection.doc()` | 通过 id 查询一条记录        |
| `collection.orderBy()` | 指定排序规则                |

多条件筛选查询：

```javascript
const _ = db.command
db.collection("users")
    .where({
        age: _.gt(20),
        married: _.eq(true),
        hobby: _.in(["吃"]),
    })
    .get()
```

API 提供了以下查询指令：

| 查询指令 | 说明                 |
| -------- | -------------------- |
| eq       | 等于                 |
| neq      | 不等于               |
| lt       | 小于                 |
| lte      | 小于或等于           |
| gt       | 大于                 |
| gte      | 大于或等于           |
| in       | 字段值在给定数组中   |
| nin      | 字段值不在给定数组中 |

#### 删除数据

删除一条数据：

```javascript
db.collection("users").doc("14139e1261246ea906a569db1559ff7b").remove()
```

删除多条数据只能在云函数端操作。

#### 修改数据

修改单条数据：

```javascript
db.collection("users")
    .doc("14139e126124657406a4061e37e34822")
    .update({
        data: {
            age: _.inc(-3)
        }
    })
```

### 重新选择当前城市业务流程

1. 新建`pages/citylist/citylist`，替换相关资源。
2. 显示城市列表。
3. 显示右侧导航，实现点击导航中的字母，直接跳转到相应位置。
4. 选择任意城市，返回到上一页，将城市名称回传给上一页。

### /重新选择当前城市业务流程

1. 新建`pages/citylist/citylist`，替换相关资源。
2. 显示城市列表。
3. 显示右侧导航，实现点击导航中的字母，直接跳转到相应位置。
4. 选择任意城市，返回到上一页，将城市名称回传给上一页。
   1. 当选择了任意城市后，将城市名称存入 `globalData` 。返回上一页即可。
   2. 在回到首页后，重写 `onShow()` ，从 `globalData` 中读取选择的城市名称，更新左上角城市名称。

### 若用户没有赋予定位权限，处理定位业务

1. 若用户没有赋予定位权限，用户依然可以选择某一个城市。
2. 当进入到城市列表页后，需要在顶部显示当前定位城市，由于没有权限，所以应该显示“定位失败，点击重试”。（意味着一旦进入`citylist`页面，就需要重新加载当前定位）
3. 重写`citylist`的`onShow`方法，重新加载当前位置。若加载失败，则显示“定位失败，点击重试”。
4. 点击该按钮，重新加载当前城市。若加载失败则弹出窗口引导用户跳转到设置页面修改授权设置。
5. 若用户重新赋予权限，则回来后重新定位当前城市。更新界面。
6. `bug`修改。

### 影院页面实现

***实现步骤***

1. 在`onShow`生命周期方法中更新左上角城市名称。（`globalData`）
2. 在`onLoad`生命周期方法中，发送请求，访问腾讯位置服务，搜索当前城市周边影院，拿到影院列表。
3. 完成列表渲染。

## 自定义组件库

### 小程序的自定义组件

```html
<button type="primary">按钮文本</button>
```

```html
<my-button color="#36d" size="big" type="round" bind:doubleclick="doclick"></my-button>
```

开发者可以将页面内的功能模块抽象成自定义组件，以便在不同的页面中重复使用；也可以将复杂的页面拆分成多个低耦合的模块，有助于代码维护。自定义组件在使用时与基础组件非常相似。

**如何自定义组件？**

1. 新建组件四件套。`wxml wxss js json`。

2. 在`wxml`与`wxss`中定义组件的默认样式。

3. 在`.json`文件中声明：我是个组件：

```javascript
   {
       "component": true
   }
```

4.在普通页面中使用该组件时，分为两步：

   1. `page.json` 中引入该组件：

```javascript
      {
          "usingComponents": {
              "自定义的组件标签名": "组件路径"
          }
      }
```

   2.在 `wxml` 中使用该组件。

```html
      <自定义的组件标签名></自定义的组件标签名>
```

## /自定义组件库

### /小程序的自定义组件

```html
<button type="primary">按钮文本</button>
```

```html
<my-button color="#36d" size="big" type="round" bind:doubleclick="doclick"></my-button>
```

开发者可以将页面内的功能模块抽象成自定义组件，以便在不同的页面中重复使用；也可以将复杂的页面拆分成多个低耦合的模块，有助于代码维护。自定义组件在使用时与基础组件非常相似。

### 如何自定义组件？

#### 新建一个自定义组件

1. 新建组件四件套。`wxml wxss js json`。

2. 在`wxml`与`wxss`中定义组件的默认样式。

3. 在`.json`文件中声明：我是个组件：

```javascript
   {
       "component": true
   }
```

4.在普通页面中使用该组件时，分为两步：

   1. `page.json` 中引入该组件：

```javascript
      {
          "usingComponents": {
              "自定义的组件标签名": "组件路径"
          }
      }
```

   2.在 `wxml` 中使用该组件。

```html
      <自定义的组件标签名></自定义的组件标签名>
```

#### 为自定义组件添加自定义属性

```html
<my-button text="去往购物车" bgcolor="#f00" type="round"></my-button>
```

需要在 `mybutton.js` 定义这些自定义属性：

```javascript
Component({
            /**
             * 声明组件的属性列表 在此处声明的属性为自定义属性
             * 可以在使用组件时指定属性值
             * <my-button text="登录"></my-button>
             * 声明的属性可以在wxml中使用{{}}引用
             */
            properties: {
                type: {
                    type: String,
                    value: 'rect'
                },
                text: {
                    type: String,
                    value: '默认按钮'
                },
                bgcolor: {
                    type: String,
                    value: '#36D'
                }
            },
            .............
        }
```

这三个属性对页面效果的影响，需要在 `wxml` 中体现：

```html
<view class="mybtn {{type}}" style="background-color:{{bgcolor}};">
    {{text}}
</view>
```

#### 为自定义组件添加自定义事件

```html
<my-button bind:doubleclick="doubleclick"></my-button>doubleclick(event){
console.log('.....');}
```

何时触发 `doubleclick` 由 `mybutton` 组件底层代码来决定。因为 `tap` 事件最底层是由 `mybutton` 中的 `view` 来捕获的。捕获 `tap` 事件处理过程中，若发现达到了 `doubleclick` 事件的触发标准，则可以通过 `this.triggerEvent('doubleclick')` 方法触发 `doubleclick` 事件，执行相关事件处理函数。

### 微信小程序组件库

微信小程序官方提供了组件库： `weui` 用于方便的搭建界面。除此之外，还有很多厂商设计了自己的组件库，如 `vant` 。所以当需要搭建小程序界面时，可以通过这些第三方组件库提供的组件，来定义页面内容与布局。

#### `weui`

这是一套基于样式库[weui-wxss](https://github.com/Tencent/weui-wxss/)开发的小程序扩展组件库，同微信原生视觉体验一致的 `UI` 组件库，由微信官方设计团队和小程序团队为微信小程序量身设计，令用户的使用感知更加统一。

#### `vant`

<https://vant-contrib.gitee.io/vant-weapp/#/home>

Vant 是**有赞前端团队**开源的移动端组件库，于 2016 年开源，已持续维护 4 年时间。Vant 对内承载了有赞所有核心业务，对外服务十多万开发者，是业界主流的移动端组件库之一。

目前 Vant 官方提供了 [Vue 版本](https://vant-contrib.gitee.io/vant)和[微信小程序版本](http://vant-contrib.gitee.io/vant-weapp)，并由社区团队维护 [React 版本](https://github.com/mxdi9i7/vant-react)。

##### 安装 `vant`

**步骤一 通过 `npm` 安装**

```shell
# 通过 npm 安装  # 进入 xzyycloud 目录后，执行该命令npm init       # 将会在根目录下新增 package.jsonnpm i @vant/weapp -S --production  # 将会新增node_modules
```

> 注意：该步骤仅仅只是从仓库中，将 `vant` 源代码包下载到本地， `node_modules` 目录并不会随着小程序打包、编译、上传、执行。需要经过步骤四才可以完成正常的小程序编译过程。

**步骤二 修改 `app.json`**

将 `app.json` 中的 `"style": "v2"` 去除，小程序的[新版基础组件](https://developers.weixin.qq.com/miniprogram/dev/reference/configuration/app.html#style)强行加上了许多样式，难以覆盖，不关闭将造成部分组件样式混乱。

**步骤三 修改 `project.config.json`**

> 在 `project.config.json` 项目配置文件中定义了项目的基本配置、打包规则等配置项。在此需要进行修改，为了告诉小程序开发工具，在步骤四中构建 `npm` 包时，从哪个目录读取 `package.json` ，以及编译后将编译好的内容输出哪一个目录下。

```json
{  ...  "setting": {    ...    "packNpmManually": true,    "packNpmRelationList": [      {        "packageJsonPath": "./package.json",        "miniprogramNpmDistDir": "./miniprogram/"      }    ]  }}
```

**步骤四 构建 `npm` 包**

打开微信开发者工具，点击**详情**，选择**本地设置**，并勾选 **使用 `npm` 模块** 选项。

点击 菜单栏中的**工具 -> 构建 `npm`**，构建完成后，即可引入组件。

> 注意：如果构建成功，将会在 `miniprogram` 目录下生成： `miniprogram_npm` ，在该目录中将会出现编译好的 `vant` 组件库代码。

***步骤五 使用***

在需要使用该组件的 `页面.json` 配置文件中，引入组件：

```json
{
  "usingComponents": {
    "my-button": "/components/mybutton/mybutton",
    "van-button": "@vant/weapp/button/index"
  }
}
```

在 `页面.wxml` 使用引入的组件：

```html
<van-button type="default">默认按钮</van-button>
<van-button type="primary">主要按钮</van-button>
<van-button type="info">信息按钮</van-button>
<van-button type="warning">警告按钮</van-button>
<van-button type="danger">危险按钮</van-button>
```

### 基于 `vant` 组件库实现“我的”页面

1. 实现基础页面结构。包括：头像、昵称、个人信息、下半部分的`cell`。
2. 实现微信登录。更新个人信息。
3. 实现更换头像（基于云存储、云数据库、云函数）。

### 实现微信登录，更新个人信息

通过 `wx.getUserProfile()` 实现微信登录，获取用户的基本信息。

```javascript
wx.getUserProfile({
    desc: "用途",
    success: (res) => {
        console.log(res)
    },
})
```

### 点击头像，更换头像

**实现步骤：**

1. 为头像绑定`tap`事件，点击后选择手机相册中的图片。
2. 图片选择完毕后，将选择好的图片上传服务器。（云存储）
3. 上传成功后，更新头像路径即可。

### 云开发之云存储

云存储类似于网盘，用户可以将需要上传的文件上传至该云存储空间中，可以在小程序段通过 `API` 对云存储空间进行管理。

**通过云开发控制台操作云存储。**

在云开发控制台可以通过相关操作上传文件。上传后的文件将被分配一个下载路径( `http://` )与云存储路径( `cloud://` )。在小程序端，可以直接访问这些路径。

#### 小程序操作云存储（将客户端的图片上传至云存储）

上传文件相关 `API` 如下：

```javascript
wx.cloud.uploadFile({
    filePath: "要上传的本地文件的路径",
    cloudPath: "上传的文件在服务端的存储路径",
    success: (res) => {
        console.log(res)
    },
})
```

**发现问题：**

虽然图片已经上传至云存储空间，但是下次登录时，依然使用的微信头像，无法获取上次登录上传的头像路径，意味着头像并没有被真正修改掉。

**这个问题的本质就是：**

虽然小程序调用 `getUserInfo` 方法获取了微信用户信息，可以方便的在客户端进行显示，但是该用户数据并没有同步到自己的服务器中。如果需要维护本项目的用户会员数据（谁是会员、谁有优惠券、新头像、新昵称等），就需要在用户登录的时候，不仅读取微信数据，还要读取本项目数据库中的用户信息。

微信登录用户，要把相关信息在本项目后端数据库中再存一份自己来维护。

若用户重新上传了头像，则将新头像路径存入本项目后端数据库中，下次登录时从本项目后端数据库中加载数据，就可以读取到新头像路径，从而实现需求。

### 当第一次使用该小程序点击登录时的业务

第一点击登录，不仅需要加载微信用户数据，还要把加载到的微信用户数据存入自己的数据库（ `mysql` 、云数据库），维护自己的用户表。为了下次登录时可以使用自己用户表中的数据。

### 云函数

云函数是一段运行在云端的代码，无需管理服务器，在开发工具内编写、一键上传部署即可运行后端代码。

小程序内提供了专门用于云函数调用的 `API` 。开发者可以在云函数内使用 [wx-server-sdk](https://developers.weixin.qq.com/miniprogram/dev/wxcloud/guide/functions/wx-server-sdk.html) 提供的 [getWXContext](https://developers.weixin.qq.com/miniprogram/dev/wxcloud/reference-sdk-api/utils/Cloud.getWXContext.html) 方法获取到每次调用的上下文（ `appid` 、 `openid` 等），无需维护复杂的鉴权机制，即可获取天然可信任的用户登录态（ `openid` ）。
